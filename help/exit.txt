Инструкция по exit

Основной синтаксис:
exit [n] — выйти из скрипта/оболочки с кодом n
exit — выйти с кодом последней выполненной команды (или 0)

Коды возврата:
0 — успех (true)
1-255 — ошибка (обычно 1)
$? — получить код возврата последней команды

Стандартные коды:
0 — успешное завершение
1 — общая ошибка
2 — неправильное использование встроенных команд
126 — команда найдена, но не исполняемая
127 — команда не найдена
128+n — завершение сигналом n (например, 130 = SIGINT/Ctrl+C)

Примеры:
exit 0 — успешный выход
exit 1 — выход с ошибкой
exit $? — выйти с кодом последней команды
exit $(($? + 10)) — увеличить код ошибки

Проверка кодов:
После выполнения скрипта: echo $?
В условиях: if команда; then ... fi

Условный выход:
    if [[ ! -f "$file" ]]; then
        echo "Файл не найден" >&2
        exit 1
    fi

Выход из функции vs скрипта:
return — выйти из функции
exit — выйти из всего скрипта

Примеры использования:
    #!/bin/bash
    # Простой скрипт с exit

    if [[ $# -eq 0 ]]; then
        echo "Использование: $0 файл"
        exit 2  # неправильное использование
    fi

    if [[ ! -f "$1" ]]; then
        echo "Ошибка: файл '$1' не существует" >&2
        exit 1
    fi

    echo "Обрабатываю файл: $1"
    # ... код обработки ...
    exit 0  # явный успешный выход
    
Выход из цикла:
    for i in {1..10}; do
        if [[ $i -eq 5 ]]; then
            echo "Достигнуто 5, выходим"
            exit 0
        fi
        echo $i
    done

Выход с сообщением:
    die() {
        echo "Фатальная ошибка: $1" >&2
        exit 1
    }

    [[ "$USER" != "root" ]] && die "Требуются права root"

Несколько условий выхода:
    if condition1; then
        exit 1
    elif condition2; then
        exit 2
    elif condition3; then
        exit 3
    fi

Выход из подпроцесса:
    (
        echo "В подпроцессе"
        exit 5
    )
    echo "Код подпроцесса: $?"  # 5
    echo "Основной скрипт продолжается"

Ловушка exit:
    trap 'echo "Скрипт завершается с кодом: $?"' EXIT

Каскадный выход:
    cleanup() {
        echo "Очистка ресурсов..."
    }

    trap cleanup EXIT

    # При любом exit будет вызван cleanup

Выход из source-скрипта:
    # sourced.sh
    if [[ "$1" == "quit" ]]; then
        return 1  # выход из source, а не exit
    fi

    # main.sh
    source ./sourced.sh
    echo "Это выполнится даже если sourced.sh сделал return"

Сигналы как коды:
130 = 128 + 2 (SIGINT/Ctrl+C)
137 = 128 + 9 (SIGKILL)
143 = 128 + 15 (SIGTERM)

Проверка в командной строке:
    bash -c 'exit 5'; echo $?  # 5

Выход без ошибки при пустом условии:
    [[ -z "$VAR" ]] && exit 0  # не ошибка, просто выход

Комбинация с test/[ :
    [ -f "/etc/passwd" ] || exit 1

Выход из case:
    case "$1" in
        start) echo "Запуск" ;;
        stop) echo "Остановка" ;;
        *) echo "Неизвестная команда"; exit 1 ;;
    esac

Пользовательские коды ошибок:
    # Определение констант
    E_GENERIC=1
    E_FILE_NOT_FOUND=2
    E_PERMISSION_DENIED=3
    E_INVALID_ARG=4

    if [[ ! -f "$1" ]]; then
        exit $E_FILE_NOT_FOUND
    fi

Обработка ошибок команд:
    command_that_might_fail || exit 1
    # или
    if ! command_that_might_fail; then
        exit 1
    fi

Выход с кодом команды:
    grep -q pattern file.txt
    exit $?  # выйти с кодом grep

Многоуровневый выход:
    main() {
        sub || exit 1
        echo "Продолжение"
    }

    sub() {
        deep || return 1
        return 0
    }

    deep() {
        [[ "$1" == "ok" ]] && return 0 || return 1
    }

    main

Безопасный выход:
    safe_exit() {
        cleanup
        sync
        exit ${1:-0}
    }
    
    trap 'safe_exit 1' INT TERM

Пример полного скрипта:
    #!/bin/bash
    # backup.sh

    E_USAGE=1
    E_NOT_ROOT=2
    E_BACKUP_FAILED=3

    # Проверка аргументов
    if [[ $# -ne 1 ]]; then
        echo "Использование: $0 <директория>"
        exit $E_USAGE
    fi

    # Проверка прав
    if [[ $EUID -ne 0 ]]; then
        echo "Требуются права root"
        exit $E_NOT_ROOT
    fi

    # Проверка директории
    if [[ ! -d "$1" ]]; then
        echo "Директория не существует: $1"
        exit $E_USAGE
    fi

    # Выполнение бэкапа
    if ! tar -czf "/backup/$(date +%Y%m%d).tar.gz" "$1"; then
        echo "Ошибка бэкапа"
        exit $E_BACKUP_FAILED
    fi

    echo "Бэкап успешно создан"
    exit 0
    
Выход из отладочного режима:
    set -e  # exit immediately on error
    # или
    set -euo pipefail  # строгий режим

Проверка после exit:
    # Этот код не выполнится после exit
    exit 1
    echo "Это не будет напечатано"

Важно:
    exit завершает текущий процесс/оболочку
    В интерактивной оболочке exit закрывает терминальную сессию
    Коды 0-255, где 0 всегда означает успех
    Для передачи данных используйте echo или файлы, не exit
