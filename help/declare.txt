Инструкция по declare (в bash)

Основной синтаксис:
declare [опции] переменная[=значение]

Опции declare

Типы переменных:
    declare -a имя        # массив (array)
    declare -A имя        # ассоциативный массив (associative array)
    declare -i имя        # целочисленная переменная (integer)
    declare -r имя        # только для чтения (readonly)
    declare -x имя        # экспорт в окружение (export)
    declare -f имя        # функция (function)
    declare -F имя        # только имя функции (без тела)

Флаги свойств:
    declare -l имя        # все буквы строчные (lowercase)
    declare -u имя        # все буквы заглавные (uppercase)
    declare -t имя        # trace (для функций)
    declare -n имя        # ссылка на другую переменную (nameref)

Примеры использования

1. Объявление массивов
    # Обычный массив
    declare -a fruits=("apple" "banana" "cherry")
    echo ${fruits[0]}     # apple
    echo ${fruits[@]}     # все элементы

    # Ассоциативный массив
    declare -A user=([name]="John" [age]=30 [city]="Moscow")
    echo ${user[name]}    # John
    echo ${user[age]}     # 30

2. Целочисленные переменные
    declare -i num
    num=10+20
    echo $num            # 30 (автоматический расчет)

    declare -i counter=0
    counter+=1           # 1
    counter=counter+2    # 3

3. Только для чтения
    declare -r PI=3.14159
    PI=3.14              # Ошибка: readonly variable

    declare -r -i MAX=100

4. Экспорт в окружение
    declare -x PATH="/usr/local/bin:$PATH"
    # Эквивалентно export PATH="/usr/local/bin:$PATH"

5. Регистр символов
    declare -l lowercase
    lowercase="HELLO"
    echo $lowercase      # hello

    declare -u uppercase
    uppercase="hello"
    echo $uppercase      # HELLO

6. Nameref (ссылки)
    declare -n ref=actual_var
    actual_var="test"
    echo $ref            # test

    ref="new value"
    echo $actual_var     # new value

7. Функции
    # Объявление функции
    declare -f myfunc
    myfunc() { echo "Hello"; }

    # Показать все функции
    declare -f

    # Показать только имена функций
    declare -F

Практические примеры

1. Инициализация сложных структур
    # Массив массивов (эмулируем)
    declare -a matrix_row1=(1 2 3)
    declare -a matrix_row2=(4 5 6)
    declare -a matrix=("matrix_row1" "matrix_row2")

    # Доступ к элементам
    declare -n row=${matrix[0]}
    echo ${row[1]}       # 2

2. Конфигурация программы
    declare -r -A config=(
        [host]="localhost"
        [port]=8080
        [debug]=false
        [timeout]=30
    )

    echo "Host: ${config[host]}"
    echo "Port: ${config[port]}"

3. Валидация ввода
    declare -i age
    read -p "Введите возраст: " age

    if [[ $age -lt 0 ]] || [[ $age -gt 150 ]]; then
        echo "Некорректный возраст"
    else
        echo "Возраст: $age"
    fi

4. Работа с регистрами
    declare -l filename
    filename="MYFILE.TXT"
    echo "$filename"     # myfile.txt

    declare -u constant
    constant="error"
    echo "$constant"     # ERROR

5. Создание псевдо-объектов
    # Эмуляция объектов через ассоциативные массивы
    declare -A person1=([name]="Alice" [age]=25 [job]="Engineer")
    declare -A person2=([name]="Bob" [age]=30 [job]="Manager")

    # Функция для работы с "объектами"
    print_person() {
        declare -n p=$1
        echo "Name: ${p[name]}, Age: ${p[age]}, Job: ${p[job]}"
    }

    print_person person1
    print_person person2

6. Константы приложения
    declare -r -i MAX_RETRIES=3
    declare -r -i TIMEOUT=60
    declare -r LOG_FILE="/var/log/app.log"
    declare -r -a ALLOWED_EXTENSIONS=("txt" "pdf" "doc")

7. Математические операции
    declare -i result
    declare -i a=10 b=20

    result=a*b           # 200
    result=2**8          # 256
    result=100/3         # 33 (целочисленное деление)

    # С плавающей точкой (через bc)
    declare result_float
    result_float=$(echo "scale=2; 100/3" | bc)
    echo $result_float   # 33.33

8. Переменные только для чтения с проверкой
    declare -r -i MIN_VALUE=0
    declare -r -i MAX_VALUE=100

    validate_range() {
        declare -i value=$1
        if (( value < MIN_VALUE || value > MAX_VALUE )); then
            echo "Вне диапазона"
            return 1
        fi
        return 0
    }

9. Экспорт переменных в функции
    setup_environment() {
        declare -x DATABASE_URL="postgres://localhost/mydb"
        declare -x API_KEY="secret-key"
        declare -x DEBUG="true"
    }

10. Работа со списками
    # Инициализация массива
    declare -a users=("alice" "bob" "charlie")

    # Добавление элементов
    users+=("david" "eve")

    # Удаление элемента
    unset users[1]  # удалить "bob"

    # Итерация
    for user in "${users[@]}"; do
        echo "User: $user"
    done

    # Длина массива
    echo "Всего пользователей: ${#users[@]}"

Специальные случаи

1. Локальные переменные в функциях
    my_function() {
        declare -i local_var=42
        declare -a local_array=(1 2 3)
        # переменные видны только внутри функции
    }

2. Глобальные переменные
    declare -g global_var="I'm global"

    function test_scope() {
        declare -g another_global="Also global"
        local local_var="I'm local"
    }

3. Объявление нескольких переменных
    declare -i a=1 b=2 c=3
    declare -r CONST1="value1" CONST2="value2"

4. Проверка существования переменных
    declare -p переменная 2>/dev/null && echo "Существует" || echo "Не существует"

5. Копирование переменных
    original="value"
    declare -n copy=original
    echo $copy  # value

6. Сброс атрибутов
    declare +i variable  # убрать integer атрибут
    declare +r variable  # убрать readonly атрибут
    declare +a array     # убрать array атрибут

Продвинутые техники

1. Динамическое создание переменных
    for i in {1..5}; do
        declare "var$i=$i"
    done

    echo $var3  # 3

2. Массивы с динамическими именами
    # Создание массива с динамическим именем
    array_name="myarray_$RANDOM"
    declare -a "$array_name"
    eval "$array_name+=('element1')"
    eval "echo \${$array_name[0]}"

3. Интроспекция переменных
    # Показать все переменные с их атрибутами
    declare -p

    # Показать конкретную переменную с атрибутами
    declare -p PATH

    # Показать все массивы
    declare -a

    # Показать все целочисленные переменные
    declare -i

4. Функции с strict режимом
    strict_function() {
        declare -i local count=0
        declare -r local max_tries=3
        declare -a local results=()
        
        # Логика функции
    }

5. Сериализация данных
    # Сохранение состояния
    save_state() {
        declare -p > state.sh
    }

    # Восстановление состояния
    load_state() {
        source state.sh
    }

Сравнение с другими способами

declare vs typeset
    # typeset - устаревший синоним declare
    typeset -i number=10
    declare -i number=10  # предпочтительнее

    declare vs local
    bash

    function test() {
        local var1="локальная"
        declare var2="тоже локальная"
        # в функциях declare создает локальные переменные
    }

declare vs export
    export MY_VAR="value"           # только экспорт
    declare -x MY_VAR="value"       # экспорт + другие атрибуты

Ошибки и отладка

1. Попытка изменить readonly
    declare -r const="value"
    const="new"  # Ошибка: readonly variable

2. Неправильное использование ассоциативных массивов
    declare -A arr
    arr[1]=10      # OK
    arr=([a]=1)    # OK
    arr=(1 2 3)    # Ошибка: нужно использовать индексы

3. Переопределение функций
    myfunc() { echo "old"; }
    declare -f myfunc  # показывает определение
    # Переопределить можно только полностью
    myfunc() { echo "new"; }

Практические шаблоны

1. Конфигурационный файл
    load_config() {
        declare -gA CONFIG
        while IFS='=' read -r key value; do
            [[ -n $key && ! $key =~ ^# ]] && CONFIG[$key]="$value"
        done < config.conf
    }

2. Безопасное вычисление
    safe_calculation() {
        declare -i result
        declare expression="$1"
        
        # Безопасное вычисление через bc
        result=$(echo "$expression" | bc 2>/dev/null)
        echo $(( result ))
    }

3. Валидатор данных
    validate_input() {
        declare -l input="${1,,}"  # приводим к нижнему регистру
        declare -a valid_options=("yes" "no" "maybe")
        
        if [[ " ${valid_options[@]} " =~ " $input " ]]; then
            return 0
        else
            return 1
        fi
    }

4. Фабрика функций
    create_greeter() {
        declare name="$1"
        declare -f greet_$name || eval "
        greet_$name() {
            echo \"Hello, $name!\"
        }"
    }

    create_greeter "John"
    greet_John  # Hello, John!

Производительность

1. Целочисленные операции быстрее
    declare -i counter=0
    for ((i=0; i<1000000; i++)); do
        counter+=1
    done

2. Локальные переменные в функциях
    # Хорошо - локальные переменные
    function fast() {
        declare -i local count
        # ...
    }

    # Плохо - глобальные переменные
    declare -i global_count
    function slow() {
        global_count=...
    }

Важные особенности
    declare без аргументов показывает все переменные
    -g делает переменную глобальной даже внутри функций
    -p показывает определение переменной
    +опция удаляет атрибут
    nameref (-n) доступен только в bash 4.3+
    Ассоциативные массивы доступны только в bash 4+

Советы
    Используйте declare -i для счетчиков и математики
    Используйте declare -r для констант
    Используйте declare -a и declare -A для структур данных
    Всегда используйте declare в функциях для локальных переменных
    Используйте declare -p для отладки

Эта инструкция покрывает все основные аспекты работы с declare в bash для
создания типизированных и безопасных переменных.

