Инструкция по eval

Основной синтаксис:
eval команда — выполнить команду, построенную из строки
eval "$строка_с_командой" — безопасное выполнение

Принцип работы:
    bash разбирает аргументы eval
    Объединяет их в одну строку
    Снова разбирает эту строку как команду
    Выполняет команду

Примеры:
eval echo "Hello" → echo "Hello" → Hello
cmd="ls -la"
eval $cmd → выполнит ls -la

Безопасное использование:
Всегда заключайте переменные в кавычки:
eval "$cmd" вместо eval $cmd

Динамические переменные:
    var_name="username"
    var_value="john"
    eval "$var_name=\"$var_value\""  # создает переменную username="john"
    echo $username  # john

Динамические имена переменных:
    for i in {1..3}; do
        eval "var$i=$i"
    done
    echo $var1 $var2 $var3  # 1 2 3

Массивы через eval:
    arr_name="myarray"
    eval "$arr_name=(1 2 3 4 5)"
    echo ${myarray[2]}  # 3

Чтение из переменной с перенаправлением:
    redir="> output.txt"
    eval echo "тест" $redir  # создаст output.txt с "тест"

Динамические команды:
    action="ls"
    options="-la"
    dir="/tmp"
    eval "$action $options $dir"

Обработка escaping:
    string='$HOME'        # строка содержит $HOME
    echo $string          # выведет $HOME
    eval echo $string     # выведет /home/user (раскроет переменную)

Пример с условным кодом:
    debug=false
    cmd='echo "Обычный режим"'
    [[ "$debug" == true ]] && cmd='set -x; echo "Отладка"'
    eval "$cmd"

Безопасная альтернатива:
    # Вместо eval можно использовать:
    array=(ls -la /tmp)
    "${array[@]}"

    # Или подстановку процессов
    bash -c "$cmd_string"

Опасные примеры (НЕ ДЕЛАТЬ):
    # Уязвимость к инъекциям
    user_input="rm -rf /"
    eval "$user_input"  # КАТАСТРОФА!

    # Лучше так:
    bash -c "$user_input"  # выполнится в отдельном процессе

Пример безопасного eval:
    # 1. Проверка содержимого
    validate_command() {
        # Разрешаем только определенные команды
        [[ "$1" =~ ^(ls|echo|date)$ ]] || return 1
    }

    # 2. Безопасное выполнение
    cmd="ls -la"
    if validate_command $(echo "$cmd" | awk '{print $1}'); then
        eval "$cmd"
    else
        echo "Запрещенная команда"
    fi

Создание функций динамически:
    func_name="myfunc"
    func_body='echo "Динамическая функция"'
    eval "$func_name() { $func_body; }"
    myfunc  # вызовет функцию

Работа с JSON/сложными структурами (осторожно!):
    # Только с доверенными данными!
    json='{"name": "John", "age": 30}'
    eval "declare -A data=($(echo "$json" | sed 's/":"/]="/g; s/":/="/g; s/{/(/g; s/}/)/g'))"
    echo ${data[name]}  # John

Пример шаблонизатора:
    template='Hello, $name! Today is $day.'
    name="Alice"
    day="Monday"
    eval echo "$template"  # Hello, Alice! Today is Monday.

Отладка eval:
    cmd='ls $HOME'
    echo "Выполняется: $cmd"  # покажет исходную строку
    set -x
    eval "$cmd"
    set +x

Чего НЕ делать с eval:
    Выполнять непроверенный пользовательский ввод
    Использовать для простых задач, где есть альтернативы
    Смешивать с внешними данными без санитизации

Альтернативы eval:
    # 1. Использовать массивы
    args=(ls -la "/path with spaces")
    "${args[@]}"

    # 2. Bash-подстановка
    ${!var_name}  # indirect expansion (только для чтения)

    # 3. declare
    declare "$var_name=$value"

    # 4. printf + bash -c
    printf -v cmd '%q ' ls -la /tmp
    bash -c "$cmd"
    
Практический пример с конфигурацией:
    # config.txt
    # timeout=10
    # retries=3
    # host="example.com"

    while read line; do
        [[ -z "$line" || "$line" =~ ^# ]] && continue
        eval "$line"  # создает переменные timeout, retries, host
    done < config.txt

    echo "Timeout: $timeout"
    echo "Host: $host"

Обработка escape-последовательностей:
    str='Hello\nWorld'
    echo -e "$str"        # две строки
    eval echo "'$str'"    # одна строка с \n

Создание алиасов динамически:
    for cmd in ll la lt; do
        eval "alias $cmd='ls -$cmd'"
    done

Безопасное чтение настроек:
    # безопасная замена
    safe_eval() {
        local line=$1
        # Удаляем опасные конструкции
        line=${line//\`/}
        line=${line//\$/\\\$}
        line=${line//\"/\\\"}
        eval "$line"
    }

    safe_eval 'path="/tmp"'

Когда использовать eval:
    Динамическое создание переменных/функций
    Чтение конфигурационных файлов
    Шаблонизация строк
    Когда нет безопасной альтернативы

Проверка перед выполнением:
    if [[ "$(type -t "$cmd")" == "function" ]]; then
        eval "$cmd"
    else
        echo "Неизвестная команда: $cmd"
    fi

Важно:
    eval выполняет код в текущем процессе shell
    Опасен с непроверенными данными
    Использовать только с доверенным вводом
    Всегда экранировать специальные символы
