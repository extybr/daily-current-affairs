Инструкция по exec

Основной синтаксис:
exec команда — заменить текущий процесс новой программой
exec > файл — перенаправить stdout для текущего shell
exec < файл — перенаправить stdin для текущего shell

Замена процесса:
exec программа — текущий shell заменяется программой
exec программа аргументы — с аргументами
После exec текущий процесс завершается

Перенаправление потоков:
exec > файл — весь вывод shell в файл
exec 2> файл — stderr в файл
exec >> файл — добавить вывод
exec < файл — читать stdin из файла

File descriptors:
exec 3> файл — открыть дескриптор 3 для записи
exec 3< файл — открыть дескриптор 3 для чтения
exec 3>&1 — дескриптор 3 копирует stdout
exec 4<&0 — дескриптор 4 копирует stdin
exec 3>&- — закрыть дескриптор 3

Примеры:

1. Замена процесса:
    exec /bin/bash          # заменить текущий shell на bash
    exec ls -la             # выполнить ls и завершить shell
    exec sleep 10           # "заснуть" и завершить shell

2. Перенаправление вывода:
    exec > output.txt       # весь вывод в файл
    echo "Тест"             # попадет в output.txt
    ls                      # тоже в output.txt
    exec > /dev/tty         # вернуть вывод на терминал

3. Перенаправление ошибок:
    exec 2> errors.log      # все ошибки в лог
    command_that_fails      # ошибка попадет в errors.log

4. Перенаправление ввода:
    exec < input.txt        # читать из файла
    read line               # прочитает из input.txt
    echo "$line"

5. Сохранение/восстановление дескрипторов:
    exec 3>&1               # сохранить stdout в дескриптор 3
    exec > log.txt          # перенаправить stdout
    echo "В лог"            # попадет в log.txt
    exec 1>&3               # восстановить stdout
    echo "На экран"         # снова на экран
    exec 3>&-               # закрыть дескриптор 3

6. Одновременное перенаправление:
    exec > output.txt 2>&1  # stdout и stderr в один файл
    # или
    exec &> output.txt      # сокращенная запись (bash)

7. Чтение файла построчно:
    exec 3< файл.txt
    while read -u 3 line; do
        echo "Строка: $line"
    done
    exec 3<&-               # закрыть дескриптор

8. Запись в несколько мест:
    exec 3> файл1.txt
    exec 4> файл2.txt
    echo "В файл1" >&3
    echo "В файл2" >&4
    exec 3>&- 4>&-

9. Создание лог-файла для скрипта:
    #!/bin/bash
    exec > script.log 2>&1  # весь вывод скрипта в лог
    echo "Начало работы"
    # ... остальной код ...

10. Подмена stdin для команды:
    exec 5<&0               # сохранить stdin
    exec < данных.txt       # подменить stdin
    read var1 var2          # читает из данных.txt
    exec 0<&5 5<&-          # восстановить stdin

11. Сокеты и сети:
    exec 3<>/dev/tcp/google.com/80  # открыть TCP соединение
    echo -e "GET / HTTP/1.0\n\n" >&3
    cat <&3                         # прочитать ответ
    exec 3<&-                       # закрыть соединение

12. Перенаправление в командной подстановке:
    # Сохранить вывод команды в переменную
    exec 3>&1                    # сохранить stdout
    output=$(command 2>&1)       # захватить вывод
    exec 1>&3                    # восстановить

13. Безопасный exec в скриптах:
    #!/bin/sh
    # После exec код не выполняется
    exec some_program
    echo "Это никогда не выполнится"

14. Запуск с другим интерпретатором:
    #!/bin/bash
    exec python <<EOF
    print("Hello from Python")
    EOF
    # bash завершается, дальше Python

15. Перенаправление для части скрипта:
    # Временное перенаправление
    {
        exec 3>&1 1>&2 2>&3  # поменять stdout и stderr местами
        echo "Это stderr"     # выведется как stderr
        ls /nonexistent       # выведется как stdout
        exec 1>&3 2>&3 3>&-   # восстановить
    } 2>/dev/null

16. Создание файла с содержимым:
    exec 3> config.conf
    cat >&3 <<EOF
    server {
        port 8080
        host localhost
    }
    EOF
    exec 3>&-

17. Чтение пароля без echo:
    exec < /dev/tty          # читать с терминала всегда
    read -s -p "Пароль: " pass
    exec < /dev/null         # отключить ввод

18. Демонизация процесса:
    #!/bin/bash
    exec > /dev/null 2>&1    # отключить весь вывод
    exec setsid some_daemon  # запустить в новой сессии

19. Запуск с ограничениями:
    exec ulimit -t 60        # ограничить время CPU 60 секундами
    exec some_computation

20. Перенаправление для всей сессии:
    # В .bashrc или профиле
    exec 2>> ~/.bash_errors  # все ошибки bash в лог

Опасные примеры:
    exec rm -rf /            # УДАЛИТ ВСЁ и завершит shell
    exec                     # завершит shell без запуска новой программы

Практические сценарии:

1. Логирование всего сеанса:
    script -f session.log    # или
    exec > >(tee session.log) 2>&1

2. Запуск веб-сервера:
    #!/bin/sh
    exec /usr/bin/python3 -m http.server 8080

3. Обработчик сигналов:
    trap 'exec >> /tmp/cleanup.log 2>&1; cleanup' EXIT

4. Подмена STDIN для диалога:
    exec 3<&0  # сохранить оригинальный stdin
    exec < <(echo -e "да\nнет\nотмена")
    select option; do ... done
    exec 0<&3  # восстановить

Важные особенности:
    После exec команда текущий shell завершается
    Перенаправления через exec действуют до конца сессии/скрипта
    Можно перенаправлять конкретные file descriptors (0-255)
    Закрытие дескрипторов: exec N>&- или exec N<&-

Безопасность:
    # Проверка перед exec
    if [[ -x "$program" ]]; then
        exec "$program"
    else
        echo "Ошибка: $program не исполняемый"
        exit 1
    fi

Отличие от eval:
exec — заменяет процесс
eval — выполняет команду в текущем процессе

В скриптах init/systemd:
    #!/bin/sh
    exec /usr/sbin/nginx -g "daemon off;"  # стандартный паттерн для демонов
