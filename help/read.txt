Инструкция по read

Основной синтаксис:
read переменная — прочитать строку в переменную
read -p "текст" переменная — показать приглашение (prompt)
read -s переменная — скрытый ввод (silent, для паролей)
read -t секунды переменная — таймаут в секундах
read -n количество переменная — прочитать указанное количество символов

Разделение на переменные:
read var1 var2 var3 — разделить строку по пробелам
read -a массив — прочитать в массив
read -r переменная — не интерпретировать обратный слеш

Разделители:
read -d разделитель — использовать указанный разделитель вместо новой строки
IFS=разделитель read — временно изменить разделитель полей

Файловый ввод:
read < файл — прочитать из файла
read переменная < /dev/tty — читать с терминала даже при перенаправлении

Примеры:
read name — прочитать имя в переменную $name
read -p "Введите имя: " name — с приглашением
read -s -p "Пароль: " pass — пароль без отображения
read -t 10 -p "Быстрее! " answer — таймаут 10 секунд
read -n 1 -p "Продолжить? [Y/n] " answer — прочитать один символ
read -r line — прочитать строку с обратными слешами
read -d ':' var — читать до двоеточия вместо новой строки
read first last — разделить ввод на две переменные
read -a array — прочитать слова в массив
IFS=, read field1 field2 — читать CSV строку
read -e variable — использовать readline (история, редактирование)

Циклы:
    while read line; do
        echo "Строка: $line"
    done < файл.txt

Чтение из пайпа:
    команда | while read data; do
        echo "Получено: $data"
    done

Чтение нескольких значений:
    echo "один два три" | read a b c
    echo "a=$a, b=$b, c=$c"

Чтение с обработкой пустых строк:
    while IFS= read -r line || [[ -n "$line" ]]; do
        echo "$line"
    done < файл

Таймаут с действием по умолчанию:
    if read -t 5 -p "Ответьте за 5 секунд: " answer; then
        echo "Вы ответили: $answer"
    else
        echo "Время вышло!"
    fi

Чтение пар ключ-значение:
    while IFS='=' read -r key value; do
        echo "Ключ: $key, Значение: $value"
    done < config.ini

Массив из строки:
    read -a words <<< "один два три четыре"
    echo "Всего слов: ${#words[@]}"
    echo "Второе слово: ${words[1]}"

Чтение с подсказкой через HERE документ:
    read -p "Выберите вариант: " choice <<EOF
    1) Первый
    2) Второй
    3) Третий
    EOF

Бесконечный цикл с выходом:
    while true; do
        read -p "Команда (q для выхода): " cmd
        [[ "$cmd" == "q" ]] && break
        echo "Выполняю: $cmd"
    done

Чтение с валидацией:
    while true; do
        read -p "Введите число от 1 до 10: " num
        if [[ "$num" =~ ^[0-9]+$ ]] && ((num >= 1 && num <= 10)); then
            break
        fi
        echo "Некорректный ввод!"
    done

Чтение пароля с подтверждением:
    while true; do
        read -s -p "Пароль: " pass1
        echo
        read -s -p "Повторите пароль: " pass2
        echo
        [[ "$pass1" == "$pass2" ]] && break
        echo "Пароли не совпадают!"
    done

Чтение с умолчанием:
    read -p "Имя пользователя [$(whoami)]: " user
    user=${user:-$(whoami)}

Чтение многострочного ввода:
    echo "Введите текст (Ctrl+D для завершения):"
    content=$(cat)
    echo "Вы ввели: $content"

Игнорирование части ввода:
    read -p "Дата (ДД.ММ.ГГГГ): " day _ month _ year
    # Ввод: 15.03.2024
    # day=15, month=03, year=2024

Чтение с сохранением разделителей:
    IFS= read -r line  # Сохраняет пробелы в начале/конце

Проверка пустого ввода:
    read -p "Введите что-нибудь: " input
    if [[ -z "$input" ]]; then
        echo "Вы ничего не ввели!"
    fi

Чтение UUID или хешей:
    read -n 32 -p "Введите MD5: " md5  # ровно 32 символа

Комбинации:
read -rst 10 var — таймаут 10 секунд, скрытый ввод, raw режим
read -p "> " -ei "значение по умолчанию" var — редактируемое значение по умолчанию

Чтение из файла построчно с номером строки:
    line_num=1
    while IFS= read -r line; do
        echo "$line_num: $line"
        ((line_num++))
    done < файл.txt

Важно:
    read без -r интерпретирует обратные слеши
    IFS= влияет на разделение полей
    При чтении из пайпа переменные теряются после цикла (в подпроцессе)
    Используйте <<< или printf для передачи строки
