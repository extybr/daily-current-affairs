Инструкция по tac

Основные опции:
tac файл — вывести файл в обратном порядке (строки)
tac -s разделитель — использовать указанный разделитель
tac -r — интерпретировать разделитель как регулярное выражение
tac -b — прикрепить разделитель к предыдущей строке
tac --help — справка
tac --version — версия

Стандартное использование:
tac файл.txt — строки файла в обратном порядке
tac — читать из stdin

Разделители:
tac -s ',' файл.csv — обратный порядок, разделитель запятая
tac -s $'\n\n' файл.txt — разделитель двойной перевод строки
tac -r -s '[.!?]' текст.txt — разделитель как регулярное выражение

Примеры:
tac log.txt — логи в обратном порядке (новые сверху)
tac /etc/passwd — пользователи в обратном порядке
seq 1 10 | tac — числа от 10 до 1
echo -e "a\nb\nc" | tac → c, b, a
tac -s '---' многострочный.txt — разделить по "---"
tac -b -s ',' данные.csv — запятые прикреплены к предыдущей строке
find . -name "*.txt" | tac — файлы в обратном порядке
history | tac | less — история команд наоборот
tail -f log.txt | tac — не работает (tac ждет EOF)

С CSV файлами:
tac -s ',' data.csv — обратный порядок записей CSV

С многострочными записями:
    # файл.txt
    Запись 1
    строка 2
    ---
    Запись 2
    строка 2
    ---

tac -s '---' файл.txt — записи в обратном порядке

С регулярными выражениями:
tac -r -s '^$' файл.txt — пустая строка как разделитель
tac -r -s '\. ' текст.txt — точка с пробелом как разделитель предложений

Вместе с другими командами:
cat файл | tac — через pipe
tac файл | grep ошибка — поиск в обратном порядке
tac файл | head -20 — последние 20 строк в нормальном порядке
sort файл | tac — сортировка по убыванию (проще: sort -r)

Практическое применение:
tac /var/log/syslog | head -50 — последние 50 записей лога (новые сверху)
tac messages.txt | grep -m 1 "ERROR" — найти последнюю ошибку
tac access.log | awk '{print $1}' | uniq | tac — уникальные IP в порядке появления
tac huge_file.txt > reversed.txt — создать обратную версию файла

Ограничения:
tac должен загрузить весь файл в память для больших файлов
Для огромных файлов лучше использовать tail -r (если доступно) или другие методы

Альтернативы:
tail -r — в некоторых системах (BSD)
awk '{lines[NR]=$0} END{for(i=NR;i>0;i--) print lines[i]}' файл
perl -e 'print reverse <>' файл
sed '1!G;h;$!d' файл — sed вариант

Обращение символов в строке:
tac обращает порядок строк, а не символов
Для символов используйте rev:
echo "hello" | rev → "olleh"

Склейка с rev:
echo "hello" | rev | tac — бессмысленно (tac для одной строки ничего не сделает)

Пример скрипта:
    # Показать последние изменения в конфиге
    tac /etc/nginx/nginx.conf | sed -n '/^# Изменено:/ {p;q}'

Проверка:
which tac — где находится tac
file $(which tac) — информация о бинарнике

Несколько файлов:
tac файл1.txt файл2.txt — каждый файл отдельно

С бинарными файлами:
tac работает с текстовыми файлами, для бинарных может дать неожиданные результаты

Без аргументов:
tac читает из stdin до Ctrl+D

Производительность:
Быстрее чем awk/perl решения для средних файлов
Для гигантских файлов может потреблять много памяти

Цепочки команд:
cat лог.txt | grep ERROR | tac | head -10 — последние 10 ошибок

Важно:
    tac — это cat наоборот (обратное написание)
    Входит в GNU coreutils
    Не всегда доступен в минимальных системах
    
Упрощенный пример работы:
    Вход:
    строка1
    строка2  
    строка3

    Выход tac:
    строка3
    строка2
    строка1
